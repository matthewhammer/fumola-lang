use std::str::FromStr;
use crate::ast::{Exp, Val, Pat, Id, Sym};

grammar;

pub ExpBox: Box<Exp> = {
    Exp => Box::new(<>)
};

pub ExpHdBox: Box<Exp> = {
    ExpHd => Box::new(<>),
}

pub Exp: Exp = {
    //<e1:ExpHdBox> ";" <e2:ExpBox> => Exp::Let(Pat::Ignore, e1, e2),
    //<e:ExpBox> "(" <v:Val> ")" => Exp::App(e, v),
    ExpHd,
};

pub ExpHd: Exp = {
    "\\" <p:Pat> "=>" <e:ExpBox> => Exp::Lambda(p, e),
    "#" <v:Val> "{" <e:ExpBox> "}" => Exp::Nest(v, e),
    <v1:Val> ":=" <v2:Val> => Exp::Put(v1, v2),
    "@" <v1:Val> => Exp::Get(v1),
    "let" <p:Pat> "=" <e1:ExpBox> ";" <e2:ExpBox> => Exp::Let(p, e1, e2),
    "let box" <p:Pat> "=" <v:Val> ";" <e:ExpBox> => Exp::LetBx(p, v, e),
    "ret" <v:Val> => Exp::Ret(v),    
    Id => Exp::Var(<>),
    ExpApp,
};

ExpApp: Exp = {
    "(" <e:ExpBox> ")" <v:Val> => Exp::App(e, v),
    <i:Id> <v:Val> => Exp::App(Box::new(Exp::Var(i)), v),
    <e:ExpApp> <v:Val> => Exp::App(Box::new(e), v),
};

pub ValBox: Box<Val> = {
    Val => Box::new(<>),
};

pub Val: Val = {
    "#" <v1:ValBox> "(" <v2:ValBox> ")" => Val::Variant(v1, v2),
    Num => Val::Num(<>),
    "`" "(" <e:ExpBox> ")" => Val::CallByValue(e),
    "$" <s:Sym> => Val::Sym(s),
    Id => Val::Var(<>),
    "{" <e:ExpBox> "}" => Val::Bx(e),
};

Num: i32 = {
    r"[0-9]+" => i32::from_str(<>).unwrap()
};

pub Pat: Pat = {
    "_" => Pat::Ignore,
    <x:Id> => Pat::Id(x),
};

pub Id: Id = {
    r"[a-zA-Z][a-zA-Z_0-9]*" => String::from_str(<>).unwrap()
};

pub SymBox: Box<Sym> = {
    Sym => Box::new(<>),
};

pub Sym: Sym = {
    <s1:SymHdBox> "_" => Sym::Bin(s1, Box::new(Sym::Under)),
    <s1:SymHdBox> "'" => Sym::Bin(s1, Box::new(Sym::Tick)),
    <s1:SymHdBox> "." <s2:SymBox> => Sym::Tri(s1, Box::new(Sym::Dot), s2),
    <s1:SymHdBox> "-" <s2:SymBox> => Sym::Tri(s1, Box::new(Sym::Dash), s2),
    SymHd,
};

pub SymHd: Sym = {
    Num => Sym::Num(<>),
    Id => Sym::Id(<>),
    "(" <s:Sym> ")" => s,
};

pub SymHdBox: Box<Sym> = {
    SymHd => Box::new(<>),
};
