use std::str::FromStr;
use crate::ast::{Exp, Val, Pat, Id, Sym, step::{Net, Trace, TraceNet}};

grammar;

pub TraceNet: TraceNet = {
  <t:Trace> ";;" <n:Net> => TraceNet { trace:t, net:n }
}

pub Trace: Trace = {
    <t1:TraceHd> ";" <t2:Trace> => Trace::Seq(vec![t1, t2]),
    TraceHd
}

pub TraceHd: Trace = {
    "ret" <v:Val> => Trace::Ret(v),
    <s:Sym> ":=" <v:Val> => Trace::Put(s, v),
    "@" <s:Sym> "=" <v:Val> => Trace::Get(s, v),
    "&" <v:Val> "=" <s:Sym> => Trace::Link(v, s),
    "#" <s:Sym> "{" <t:Trace> "}" => Trace::Nest(s, Box::new(t))
}

pub NetHd: Net = {
    "doing" <s:Sym> "{" <e:Exp> "}" => Net::Running(s, e),
    "being" <s:Sym> "{" <v:Val> "}" => Net::Halted(s, v),
}

pub NetHdBox: Box<Net> = {
    NetHd => Box::new(<>)
}

pub Net: Net = {
    <n1:NetHdBox> "|" <n2:NetBox> => Net::Gather(n1, n2),
    NetHd,
}

pub NetBox: Box<Net> = {
    Net => Box::new(<>),
}

pub ExpBox: Box<Exp> = {
    Exp => Box::new(<>)
};

pub ExpHdBox: Box<Exp> = {
    ExpHd => Box::new(<>),
}

pub Exp: Exp = {
    //<e1:ExpHdBox> ";" <e2:ExpBox> => Exp::Let(Pat::Ignore, e1, e2),
    //<e:ExpBox> "(" <v:Val> ")" => Exp::App(e, v),
    ExpHd,
};

pub ExpHd: Exp = {
    "\\" <p:Pat> "=>" <e:ExpBox> => Exp::Lambda(p, e),
    "#" <v:Val> "{" <e:ExpBox> "}" => Exp::Nest(v, e),
    <v1:Val> ":=" <v2:Val> => Exp::Put(v1, v2),
    "@" <v1:Val> => Exp::Get(v1),
    "&" <v1:Val> => Exp::Link(v1),
    "assert_equal" <v1:Val> <v2:Val> => Exp::AssertEq(v1, true, v2),
    "let" <p:Pat> "=" <e1:ExpBox> ";" <e2:ExpBox> => Exp::Let(p, e1, e2),
    "let box" <p:Pat> "=" <v:Val> ";" <e:ExpBox> => Exp::LetBx(p, v, e),
    "ret" <v:Val> => Exp::Ret(v),    
    Id => Exp::Extract(Val::Var(<>)),
    ExpApp,
};

ExpApp: Exp = {
    "(" <e:ExpBox> ")" <v:Val> => Exp::App(e, v),
    <i:Id> <v:Val> => Exp::App(Box::new(Exp::Extract(Val::Var(i))), v),
    <e:ExpApp> <v:Val> => Exp::App(Box::new(e), v),
};

pub ValBox: Box<Val> = {
    Val => Box::new(<>),
};

pub Val: Val = {
    "#" <v1:ValBox> "(" <v2:ValBox> ")" => Val::Variant(v1, v2),
    Num => Val::Num(<>),
    "`" "(" <e:ExpBox> ")" => Val::CallByValue(e),
    "$" <s:Sym> => Val::Sym(s),
    Id => Val::Var(<>),
    "{" <e:ExpBox> "}" => Val::Bx(e),
    "!" <s:Sym> => Val::Ptr(s),
};

Num: i32 = {
    r"[0-9]+" => i32::from_str(<>).unwrap()
};

pub Pat: Pat = {
    "_" => Pat::Ignore,
    <x:Id> => Pat::Id(x),
};

pub Id: Id = {
    r"[a-zA-Z][a-zA-Z_0-9]*" => String::from_str(<>).unwrap()
};

pub SymBox: Box<Sym> = {
    Sym => Box::new(<>),
};

pub Sym: Sym = {
    <s1:SymHdBox> "_" => Sym::Bin(s1, Box::new(Sym::Under)),
    <s1:SymHdBox> "'" => Sym::Bin(s1, Box::new(Sym::Tick)),
    <s1:SymHdBox> "." <s2:SymBox> => Sym::Tri(s1, Box::new(Sym::Dot), s2),
    <s1:SymHdBox> "-" <s2:SymBox> => Sym::Tri(s1, Box::new(Sym::Dash), s2),
    SymHd,
};

pub SymHd: Sym = {
    Num => Sym::Num(<>),
    Id => Sym::Id(<>),
    "(" <s:Sym> ")" => s,
};

pub SymHdBox: Box<Sym> = {
    SymHd => Box::new(<>),
};

