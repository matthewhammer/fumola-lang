\documentclass[11pt]{article}

\newcommand{\ottnt}[1]{\ensuremath{mathit{#1}}}
\newcommand{\ottmv}[1]{\ensuremath{\mathit{#1}}}
\newcommand{\ottkw}[1]{\ensuremath{\mathbf{#1}}}
\newcommand{\ottcom}[1]{{#1}}
\newcommand{\ottsym}[1]{{#1}}

\begin{document}

\section*{Fumola core calc examples}

Minimal syntax description, in terms of core calculus in Ott.

\subsection*{Basic forms}

\paragraph{Meta variables for program variables}

\[ [[ x ]], [[ y ]], [[ z ]]\]

When using lexically-scoped variables that follow the usual principles
of substitution and alpha conversion, we use italics (as with $x, y,
z$, above).  Italics distinguish these meta variables from
\emph{symbols}, that do not follow ordinary lexical scoping or
substitution rules.

\paragraph{Symbols (as trees)}

Fumola is distinguished from functional languages in how it models
symbolic effects.

In fumola, symbols serve several interconnected roles:

\begin{itemize}

\item
Symbols are first-class values.

\item
Symbols organize and address global state, where programs do put and get operations.

\item
Symbol sets index types as type refinements,
indicating what symbols and addresses their values contain.

\item
Collections of symbols have internal structure as familes of trees, and

\item
The collective design of symbolic structure by programmers fully determines
incremental caching and reuse semantics for their program's behavior.

\end{itemize}

Unlike lexically-bound variables, symbols in Fumola use a semantics of
program effects, and are not meant to be ``meaningless'' or
freely alpha-converted into other symbols.

Rather, symbolic choices are chosen carefully
by the programmer to have certain properties and encode certain data
relationships.

Because these choices reflect a deliberate design with important determinative qualities for cache performance, they should be carried through the
programming language system, to the extent this is possible, not discarded.


To this end, Fumola's type and effect system attempts to prove each
program's reasoning about incremental reuse, in terms of symbolic
state names, is correct --- (to do -- more details elsewhere on the
verification conditions of Fumola programs, and how they relate to
incremental efficiency and correctness.)

Concretely, each symbol is generally a \emph{tree}, formed from binary
connectives, balanced delimiters and possibly other (simple) connective forms.

Atomic symbols, as examples, letters 'a' and 'b', 'x':

\[ [[ a ]]\]

\[ [[ b ]]\]

\[ [[ xSymbol ]]\]

Atomic symbol sequencing (note the slight space between the letters):

\[ [[ a b c ]]\]

Notice there are spaces here and throughout.
We use these spaces for the Ott parsing technique here but they have
no meaning.
(In Fumola, most symbol trees are free of spaces, like
identifers in ordinary programming languages.)
Our future parsers will not require spaces to parse symbol sequences made of individual letters.

Sequences with balanced delimiters (paren, brace, bracket):

\[ [[ ( a b c ) ]]\]

\[ [[ a ( b { c } a ) ]]\]

\[ [[ a ( ( b ) ( ) [ c b ] ) ]]\]

With commas and other internal delimiters

\[ [[ a ( b , ,  b  , a ) ]]\]

\[ [[ a ( c ; { b } ; , a ) ]]\]

\[ [[ a ( ( , - - c , ) ( ) [ b | a b ( c a ) a ] ) ]]\]

\paragraph{Symbol-tree terms}

We prefix symbol trees with \textbf{\$} to promote them into constant
terms.

\[ [[ $ a ]]\]

\[ [[ $ a b b a ]]\]

 Within the constant's concrete syntax, we can even use distinguished
symbols from the language (like the arrow for functions) as symbols
with domain-specific (or program-specific) meaning

\[ [[ $ a b * => b * a ]]\]

To avoid this parsing, we can disambiguate with outer parenthesis when needed

\[ [[ (\x => ($b) * x) $ a ]]\]

Notice that we use parenthesis to delimit the end of symbol $[[ $b ]]$.

If we omit them, we could mis-parse terms that use special symbols.

For instance, the $\underline{\cdot}$ symbol, which is written
concretely as an asterisk, could be mistaken as part of the symbol
constant beginning with [[ $ b ]] above.

Similarly, we would consume the variable $x$ as part of that symbol too if we omit those parenthesis:

\[ [[ (\x => $b * xSymbol) $ a ]]\]

We use the parens to avoid this parsing, which was not our intention.


\paragraph{Binary combinations of terms}

Each is distinct:

\[ [[ ($ a) * $ z a ]]\]

\[ [[ ($ a) * (($ z a) * $ z a) ]]\]

\[ [[ (($ a ) * $ z a ) * ($ z a) ]]\]

We use the parens above to avoid unintended parses.

Recall that they can also be present in the symbol structure, as symbol structure:

\[ [[ ($ (a)) * $ (z) a ]]\]

\[ [[ ($ a) * $ z (a) ]]\]

\[ [[ ($ a) * $ (z a) ]]\]

Each of these examples is distinct, and each is distinct from

\[ [[ ($ a) * $ z a ]]\]

which is equal to all of these

\[ [[ (($ a) * $ z a) ]]\]

\[ [[ ((($ a) * $ z a)) ]]\]

\[ [[ (((($ a) * $ z a))) ]]\]

The extra parenthesis \emph{around} the symbol tree terms play no role
except to help parse that outermost tree form in the presence of any
enclosing terms.  But more than a single extra enclosure is not ever
needed.

Consider

\[ [[ (\x => ($b) * x) $ a ]]\]

This function is applied to the term

 \[ [[ $a ]] \]

and thus, the whole term normalizes as

 \[ [[ ($b) * $a ]] \]


\subsection*{Value and expression forms}

\paragraph{Symbol trees as injected values}

Prefix a symbol tree with hash to create a variant constructor name.

Each distinct symbol tree is a distinct variant constructor (type).

\[ [[ # $ a b b a ]]\]

\[ [[ # ($ a b ) * ($ b a) ]]\]

\[ [[ # ($ a ) * ($ b ) * ($ b a) ]]\]

Symbol trees in fumola are first-class values, and these constructor names can be parameterized using these values.

This function creates a constructor value using its parameter, a symbol tree, and returns this value:

\[ [[ \x => return # x ]] \]

\paragraph{Put values into ambient state.}

Store value [[ #$ a b c ]] into address named [[ $a ]], and return that name as an adddress:

\[ [[ let x = ($a := #$ a b c) ; return x]] \]

We use the parens for readability, but they are optional:

\[ [[ let x = $a := #$ a b c ; return x]] \]

\paragraph{Get the value back from that address.}

\[ [[ @x ]] \]

If no other puts have occurred on this address, then the value of that get operation is

\[ [[ #$ a b c ]] \]

Alternatively, we can assemble the address ourselves and do the get without the let-bound variable $x$:

\[ [[ let y = &$a ; @y ]] \]

also results in getting the same address, and its value

\[ [[ #$ a b c ]] \]

\paragraph{Call-by-push value syntax}

A practical version of Fumola would permit call-by-value syntax.

But in our Ott development, we are using a more restricted form of syntax, call by push value.

This core calculus form of Fumola minimizes its syntactic complexity,
often at the cost of writing more intermediate let-bindings in our
examples.

For instance, we write these two steps with a let binding

\[ [[ let y = &$a ; @y ]] \]

Instead of combining the get and address operations into a single expression,
and conceptually one step.

This verbosity in examples saves on complexity in the formal system, and is worth it.

\paragraph{Named nested expressions}

\[ [[ $a { $b { $c { $xSymbol { return $3 } } } } ]] \]

\end{document}
