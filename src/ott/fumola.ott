metavar x ::=  
{{ coq nat}} {{ coq-equality }}

grammar

terminals :: 'terminals_' ::=
| \ :: :: lambda {{ tex \lambda }}
| -> :: :: rightarrow {{ tex \rightarrow }}
| => :: :: thickrightarrow {{ tex \Rightarrow }}
| #map :: :: map {{ tex \texttt{map} }}
| #set :: :: set {{ tex \texttt{set} }}
| #ord :: :: ord {{ tex \texttt{ord} }}
| #    :: :: hash {{ tex \texttt{\#} }}
| #empty :: :: empty {{ tex \cdot }}
| ~ :: :: tilde {{ tex \sim }}

G {{ tex \Gamma }} :: 'G_' ::= {{ com Contexts. }}
 | #empty       :: :: empty {{ tex \cdot }}
 | G , x : kind :: :: hasKind
 | G , x : sort :: :: hasSort
 | G , x : A    :: :: hasType

A :: 'A_' ::= {{ com Value types. }}
 | X :: :: preciseSymbol
 | ~ X :: :: approxSymbol
 | & X :: :: preciseAddress
 | ~ & X :: :: approxAddress
 | { C } :: :: computationType
 | { variantCases } :: :: variantType
 | { recordFields } :: :: productType

variantCases :: 'variantCases_' ::=
 | :: :: empty
 | # X : A :: :: variant

recordFields :: 'recordFields_' ::=
 | :: :: empty
 | X : A :: :: variant

C :: 'C_' ::= {{ com Computation types. }}
 | E ; C :: :: effectComp
 | A -> C :: :: argumentValue
 | A :: :: returnValue
 | { namedComps } :: :: namedComps

namedComps :: 'namedComps_' ::=
 | :: :: empty
 | X => C , namedComps :: :: namedComps

E :: 'E_' ::= {{ com Computation effects. }}
 | #empty :: :: empty
 | E1 ; E2 :: :: sequence
 | X := A :: :: put
 | @ X :: :: get

S :: 'syms_ ::= {{ com Symbol sequences. }}
 | :: :: empty
 | s S :: :: oneMore
 | ( S ) :: :: balParen
 | [ S ] :: :: balBrack
 | { S } :: :: balBrace

sort {{ tex \gamma }} :: 'sort_' ::= {{ com Name sorts. }}
 | #syms :: :: syms
 | #set ( sort ) :: :: set
 | #ord ( sort ) :: :: ord
 | #map ( sort1 , sort2 ) :: :: map
 | sort1 -> sort2 :: :: arrow
 | ( sort ) :: :: paren

X, Y, Z :: 'term_' ::= {{ com Symbolic-name terms. }}
 | as sort have X :: :: annotate
 | $ S :: :: symbols
 | $( S ) :: :: symbolsDelim
 | !$ X :: :: flatten
 | X * Y :: :: binaryForm
 | X * [ Y ] Z :: :: ternaryForm
 | X , Y :: :: gather
 | \ x => X :: :: defineFn (+ bind x in X +)
 | \ x := X :: :: defineRec (+ bind x in X +)
 | X ^* Y :: :: stepStar
 | X +* Y :: :: plusStar
 | X >> Y :: :: map
 | X Y :: :: applyFn
 | X => Y :: :: associate
 | X % Y :: :: project
 | ( X ) :: :: paren

v :: 'v_' ::= {{ com Values. }}
 | x :: :: var
 | # v :: :: injectUnit {{ com inject unit value into variant type. }}
 | # v1 ( v2 ) :: :: inject {{ com inject into variant type. }}
 | v1 , v2 => v3 :: :: extend {{ com extend a record type. }}
 | X :: :: preciseSymbol {{ com precise symbol. }}
 | ~ X :: :: approxSymbol {{ com approximate symbol. }}

e :: 'e_' ::= {{ com Minimal expressions. }}
 | let x = e1 ; e2 :: :: letBind
 | let fields = v ; e :: :: letBindRecord
 | switch v { cases } :: :: switchVariant
 | return v :: :: return
 | \ x := e :: :: defineRec
 | \ x => e :: :: defineFn
 | e v :: :: applyFn
 | assert v1 = v2 :: :: assertEq
 | v1 := v2 :: :: put
 | @ v1 :: :: get
 | { namedBranches } :: :: namedBranches
 | e => v :: :: selectBranch
 | desugar [[ eS ]] :: :: sugar {{ com implicitly placed by full-syntax parser. }}

eS :: 'eS_' ::= {{ com Sugar expression forms. }}
 | let fields = e1 ; e2 :: :: letBind
 | \ fields => e :: :: defineFn
 | \ switch { cases } :: :: casesFn

namedBranches :: 'namedBranches_' ::=
 | :: :: empty
 | v => e , namedBranches :: :: branch

pat :: 'pat_' ::= {{ com Pattern-match expression. }}
 | _ :: :: ignoreMatch
 | x :: :: bindMatch
 | { fields } :: :: fieldsMatch {{ com Record elim form. }}

fields :: 'fields_' ::= {{ com Product-type fields. }}
 | v => pat , fields :: :: field
 | x :: :: bindRest

cases :: 'cases_' ::= {{ com Variant-type cases. }}
 | # v ( pat ) => e ; cases :: :: case
 | otherwise e :: :: otherwise



s :: 'sym_' ::= {{ com Atomic symbols. }}
 | ! :: :: bang
 | " :: :: dtick
 | # :: :: hashsign
 | $ :: :: dollar
 | & :: :: amp
 | ' :: :: tick
 | '|' :: :: pipe
 | * :: :: star
 | + :: :: plus
 | , :: :: comma
 | - :: :: dash
 | . :: :: dot
 | / :: :: fslash
 | 0 :: :: zero
 | 1 :: :: one
 | 2 :: :: two
 | 3 :: :: three
 | 4 :: :: four
 | 5 :: :: five
 | 6 :: :: six
 | 7 :: :: seven
 | 8 :: :: eight
 | 9 :: :: nine
 | : :: :: colon
 | ; :: :: semi
 | < :: :: less
 | = :: :: equalsign
 | > :: :: grtr
 | ? :: :: quest
 | @ :: :: atsign
 | \ :: :: bslash
 | ^ :: :: caret
 | _ :: :: under
 | ` :: :: btick
 | ~ :: :: tilde
 | a :: :: a
 | z :: :: z
 | 'A' :: :: A
 | 'Z' :: :: Z


kind {{ tex K }} :: kind_ ::= {{ com Kinds. }}
 | #type :: :: type
 | #sort :: :: sort
 | kind1 -> kind2 :: :: arrow

substitutions
single X x :: tsubst

defns J :: '' ::= 

defn
G |- sort1 = sort2 : kind ::  :: sortEqual :: 'sort_' by

defn
#sortIsFlat sort ::  :: sortIsFlat :: 'sortIsFlat_' by

------------------ :: syms
#sortIsFlat #syms

#sortIsFlat sort
----------------------- :: set
#sortIsFlat #set(sort)

#sortIsFlat sort1
#sortIsFlat sort2
------------------------------ :: map
#sortIsFlat #map(sort1, sort2)

defn
G |- X : sort ::  :: sort :: 'sort_' by

----------------- :: symbols
G |- $ S : #syms

G |- X : sort
#sortIsFlat sort
----------------- :: flatten
G |- !$ X : #syms

G |- X : sort2
G |- sort1 = sort2 : kind
---------------------------- :: annot
G |- as sort1 have X : sort1


G |- X : #syms
G |- Y : sort
#sortIsFlat sort
-------------------------------- :: symsL
G |- X * Y : sort

G |- X : sort
G |- Y : #syms
#sortIsFlat sort
-------------------------------- :: symsR
G |- X * Y : sort

G |- X : #syms
G |- Y : #syms
G |- Z : sort
#sortIsFlat sort
------------------------ :: ternL
G |- X *[ Y ] Z : sort

G |- X : sort
G |- Y : #syms
G |- Z : #syms
#sortIsFlat sort
------------------------ :: ternR
G |- X *[ Y ] Z : sort



G |- X : #set(sort)
G |- Y : #set(sort)
------------------------ :: gSet
G |- X , Y : #set(sort)

G |- X : #ord(sort)
G |- Y : #ord(sort)
------------------------ :: gOrd
G |- X , Y : #ord(sort)

G |- X : #map(sort1, sort2)
G |- Y : #map(sort1, sort2)
--------------------------------- :: gMap
G |- X , Y : #map(sort1, sort2)

G, x : sort1 |- X : sort2
-------------------------- :: fn
G |- \x => X : sort1 -> sort2

G, x : sort |- X : sort
-------------------------- :: rec
G |- \x := X : sort

G |- X : sort1 -> sort2
G |- Y : sort1
------------------- :: app
G |- X Y : sort2


G |- X : sort1
G |- Y : sort2
--------------------------------- :: associate
G |- X => Y : #map(sort1, sort2)

G |- X : #map(sort1, sort2)
G |- Y : sort1
--------------------------------- :: projMem
G |- X % Y : sort2

G |- X : #map(sort1, sort2)
G |- Y : #set(sort1)
--------------------------------- :: projSet
G |- X % Y : #set(sort2)


G |- X : #set(sort)
G |- Y : sort -> #set(sort)
---------------------------- :: stepStar
G |- X ^* Y : #set(sort)

G |- X : #set(sort)
G |- Y : sort -> #set(sort)
---------------------------- :: plusStar
G |- X +* Y : #set(sort)


G |- X : #syms
G |- Y : #syms -> #syms
---------------------------- :: mapSyms
G |- X >> Y : #syms

G |- X : #set(sort)
G |- Y : sort -> #set(sort)
---------------------------- :: mapSet
G |- X >> Y : #set(sort)

G |- X : #ord(sort)
G |- Y : sort -> #ord(sort)
---------------------------- :: mapOrd
G |- X >> Y : #ord(sort)

G |- X : #map(sort1, sort2)
G |- Y : sort1 -> (sort2 -> #map(sort1', sort2'))
------------------------------------------------- :: mapMap
G |- X >> Y : #map(sort1', sort2')

