metavar x , y , z ::=
{{ coq nat}} {{ coq-equality }}

grammar

terminals :: 'terminals_' ::=
| \ :: :: lambda {{ tex \lambda }}
| -> :: :: rightarrow {{ tex \rightarrow }}
| => :: :: thickrightarrow {{ tex \Rightarrow }}
| := :: :: defineOrAssign {{ tex \texttt{:=} }}
| ^* :: :: stepStar {{ tex \texttt{\^{}*} }}
| +* :: :: plusStar {{ tex \texttt{+*} }}
| & :: :: amp {{ tex \texttt{\&} }}
| $ :: :: dollar {{ tex \texttt{\$} }}
| @ :: :: at {{ tex \texttt{@} }}
| >> :: :: mapOp {{ tex \texttt{>>} }}
| % :: :: projectOp {{ tex \texttt{\%} }}
| #map :: :: map {{ tex \texttt{map} }}
| #set :: :: set {{ tex \texttt{set} }}
| #ord :: :: ord {{ tex \texttt{ord} }}
| #    :: :: hash {{ tex \texttt{\#} }}
| #empty :: :: empty {{ tex \cdot }}
| ~ :: :: tilde {{ tex \sim }}
| |- :: :: vdash {{ tex \vdash }}
| ~> :: :: becomes {{ tex \leadsto }}

G {{ tex \Gamma }} :: 'G_' ::= {{ com Contexts. }}
 | #empty       :: :: empty {{ tex \cdot }}
 | G , x : kind :: :: hasKind
 | G , x : sort :: :: hasSort
 | G , x : A    :: :: hasType
 | G , past X   :: :: past {{ com past [[X]] }}
 | G , within X   :: :: within {{ com within [[X]] }}

A :: 'A_' ::= {{ com Value types. }}
 | $ X :: :: symbol {{ com Symbol. }}
 | & X A :: :: address {{ com Address. }}
 | { C } :: :: suspComp {{ com Suspended computation (thunk). }}
 | { variantCases } :: :: variantType {{ com Sum type. }}
 | { recordFields } :: :: productType {{ com Product type. }}

variantCases :: 'variantCases_' ::=
 | :: :: empty
 | # X : A :: :: variant

recordFields :: 'recordFields_' ::=
 | :: :: empty
 | X : A :: :: variant

C :: 'C_' ::= {{ com Computation types. }}
 | X { C } :: :: nestedComp
 | E ; C :: :: effectComp
 | A -> C :: :: argumentValue
 | A :: :: returnValue
 | { namedComps } :: :: namedComps

namedComps :: 'namedComps_' ::=
 | :: :: empty
 | X => C , namedComps :: :: namedComps

E :: 'E_' ::= {{ com Computation effects. }}
 | X { E } :: :: nest
 | past X :: :: past
 | E1 ; E2 :: :: sequence
 | X := A :: :: put
 | @ X = A :: :: get
 | return A :: :: return

S :: 'syms_ ::= {{ com Symbol sequences. }}
 | :: :: empty
 | s S :: :: oneMore
 | ( S ) :: :: balParen
 | [ S ] :: :: balBrack
 | { S } :: :: balBrace

sort {{ tex \gamma }} :: 'sort_' ::= {{ com Name sorts. }}
 | #syms :: :: syms
 | #set ( sort ) :: :: set
 | #ord ( sort ) :: :: ord
 | #map ( sort1 , sort2 ) :: :: map
 | sort1 -> sort2 :: :: arrow
 | ( sort ) :: :: paren

X, Y, Z :: 'term_' ::= {{ com Symbolic-name terms. }}
 | as sort have X :: :: annotate
 | $ S :: :: symbols
 | $( S ) :: :: symbolsDelim
 | !$ X :: :: flatten
 | X * Y :: :: binaryForm
 | X * [ Y ] Z :: :: ternaryForm
 | X , Y :: :: gather
 | \ x => X :: :: defineFn (+ bind x in X +)
 | \ x := X :: :: defineRec (+ bind x in X +)
 | X ^* Y :: :: stepStar
 | X +* Y :: :: plusStar
 | X >> Y :: :: map
 | X Y :: :: applyFn
 | X => Y :: :: associate
 | X % Y :: :: project
 | ( X ) :: :: paren
 | x :: :: var

v :: 'v_' ::= {{ com Values. }}
 | x :: :: var
 | # v :: :: injectUnit {{ com inject unit value into variant type. }}
 | # v1 ( v2 ) :: :: inject {{ com inject into variant type. }}
 | v1 , v2 => v3 :: :: extend {{ com extend a record type. }}
 | X :: :: preciseSymbol {{ com precise symbol. }}
 | ~ X :: :: approxSymbol {{ com approximate symbol. }}

e :: 'e_' ::= {{ com Minimal expressions. }}
 | X { e } :: :: nest
 | let x = e1 ; e2 :: :: letBind
 | let fields = v ; e :: :: letBindRecord
 | switch v { cases } :: :: switchVariant
 | return v :: :: return
 | \ x := e :: :: defineRec
 | \ x => e :: :: defineFn
 | e v :: :: applyFn
 | assert v1 = v2 :: :: assertEq
 | v1 := v2 :: :: put
 | @ v1 :: :: get
 | { namedBranches } :: :: namedBranches
 | e => v :: :: selectBranch
 | desugar [[ eS ]] :: :: sugar {{ com implicitly placed by full-syntax parser. }}

eS :: 'eS_' ::= {{ com Sugar expression forms. }}
 | let fields = e1 ; e2 :: :: letBind
 | \ fields => e :: :: defineFn
 | \ switch { cases } :: :: casesFn

namedBranches :: 'namedBranches_' ::=
 | :: :: empty
 | v => e , namedBranches :: :: branch

pat :: 'pat_' ::= {{ com Pattern-match expression. }}
 | _ :: :: ignoreMatch
 | x :: :: bindMatch
 | { fields } :: :: fieldsMatch {{ com Record elim form. }}

fields :: 'fields_' ::= {{ com Product-type fields. }}
 | v => pat , fields :: :: field
 | x :: :: bindRest

cases :: 'cases_' ::= {{ com Variant-type cases. }}
 | # v ( pat ) => e ; cases :: :: case
 | otherwise e :: :: otherwise

t :: 'trace_' ::= {{ com Trace. }}
 | return v :: :: value
 | t1 ; t2 :: :: seq
 | X := v :: :: put
 | @ X = v :: :: get
 | X { t } :: :: nest


s :: 'sym_' ::= {{ com Atomic symbols. }}
 | ! :: :: bang
 | " :: :: dtick
 | # :: :: hashsign
 | $ :: :: dollar
 | & :: :: amp
 | ' :: :: tick
 | '|' :: :: pipe
 | * :: :: star
 | + :: :: plus
 | , :: :: comma
 | - :: :: dash
 | . :: :: dot
 | / :: :: fslash
 | 0 :: :: zero
 | 1 :: :: one
 | 2 :: :: two
 | 3 :: :: three
 | 4 :: :: four
 | 5 :: :: five
 | 6 :: :: six
 | 7 :: :: seven
 | 8 :: :: eight
 | 9 :: :: nine
 | : :: :: colon
 | ; :: :: semi
 | < :: :: less
 | = :: :: equalsign
 | > :: :: grtr
 | ? :: :: quest
 | @ :: :: atsign
 | \ :: :: bslash
 | ^ :: :: caret
 | _ :: :: under
 | ` :: :: btick
 | ~ :: :: tilde
 | a :: :: a
 | z :: :: z
 | 'A' :: :: A
 | 'Z' :: :: Z


kind {{ tex K }} :: kind_ ::= {{ com Kinds. }}
 | #type :: :: type
 | #sort :: :: sort
 | kind1 -> kind2 :: :: arrow

substitutions
single X x :: tsubst

defns J :: '' ::=

defn
G |- sort1 = sort2 : kind ::  :: sortEqual :: 'sort_' by


defn #sortIsFlat sort :: :: sortIsFlat :: 'flat_' by

------------------ :: syms
#sortIsFlat #syms

#sortIsFlat sort
----------------------- :: set
#sortIsFlat #set(sort)

#sortIsFlat sort1
#sortIsFlat sort2
------------------------------ :: map
#sortIsFlat #map(sort1, sort2)



defn
G |- X : sort ::  :: sort :: 'sort_' by

----------------- :: symbols
G |- $ S : #syms

G |- X : sort
#sortIsFlat sort
----------------- :: flatten
G |- !$ X : #syms

G |- X : sort2
G |- sort1 = sort2 : kind
---------------------------- :: annot
G |- as sort1 have X : sort1


G |- X : #syms
G |- Y : sort
#sortIsFlat sort
-------------------------------- :: symsL
G |- X * Y : sort

G |- X : sort
G |- Y : #syms
#sortIsFlat sort
-------------------------------- :: symsR
G |- X * Y : sort

G |- X : #syms
G |- Y : #syms
G |- Z : sort
#sortIsFlat sort
------------------------ :: ternL
G |- X *[ Y ] Z : sort

G |- X : sort
G |- Y : #syms
G |- Z : #syms
#sortIsFlat sort
------------------------ :: ternR
G |- X *[ Y ] Z : sort



G |- X : #set(sort)
G |- Y : #set(sort)
------------------------ :: gSet
G |- X , Y : #set(sort)

G |- X : #ord(sort)
G |- Y : #ord(sort)
------------------------ :: gOrd
G |- X , Y : #ord(sort)

G |- X : #map(sort1, sort2)
G |- Y : #map(sort1, sort2)
--------------------------------- :: gMap
G |- X , Y : #map(sort1, sort2)

G, x : sort1 |- X : sort2
-------------------------- :: fn
G |- \x => X : sort1 -> sort2

G, x : sort |- X : sort
-------------------------- :: rec
G |- \x := X : sort

G |- X : sort1 -> sort2
G |- Y : sort1
------------------- :: app
G |- X Y : sort2


G |- X : sort1
G |- Y : sort2
--------------------------------- :: associate
G |- X => Y : #map(sort1, sort2)

G |- X : #map(sort1, sort2)
G |- Y : sort1
--------------------------------- :: projMem
G |- X % Y : sort2

G |- X : #map(sort1, sort2)
G |- Y : #set(sort1)
--------------------------------- :: projSet
G |- X % Y : #set(sort2)


G |- X : #set(sort)
G |- Y : sort -> #set(sort)
---------------------------- :: stepStar
G |- X ^* Y : #set(sort)

G |- X : #set(sort)
G |- Y : sort -> #set(sort)
---------------------------- :: plusStar
G |- X +* Y : #set(sort)


G |- X : #syms
G |- Y : #syms -> #syms
---------------------------- :: mapSyms
G |- X >> Y : #syms

G |- X : #set(sort)
G |- Y : sort -> #set(sort)
---------------------------- :: mapSet
G |- X >> Y : #set(sort)

G |- X : #ord(sort)
G |- Y : sort -> #ord(sort)
---------------------------- :: mapOrd
G |- X >> Y : #ord(sort)

G |- X : #map(sort1, sort2)
G |- Y : sort1 -> (sort2 -> #map(sort1', sort2'))
------------------------------------------------- :: mapMap
G |- X >> Y : #map(sort1', sort2')



defn
G ~> X ; Y ::  :: contextNameFns :: 'nfns_' by


---------------------------- :: emp
#empty ~> \x => x ; \y => y

G ~> X ; Y
--------------------- :: varKind
G, x : kind ~> X ; Y

G ~> X ; Y
----------------------- :: varSort
G, x : sort ~> X ; Y

G ~> X ; Y
----------------- :: varType
G, x : A ~> X ; Y

G ~> X ; Y
-------------------------------- :: past
G, past Y ~> X ; \y => (Y * y)

G ~> X1 ; Y
---------------------------------------------- :: within
G, within X2 ~> \x => (X1 (X2 * x)) ; \y => y

defn
G1 |- E ~> G2 ::  :: effContext :: effContext_' by

---------------------------- :: past
G1 |- past X ~> G, past X

G1 |- E1 ~> G2
G2 |- E2 ~> G3
------------------ :: seq
G1 |- E1 ; E2 ~> G3

------------------ :: get
G1 |- @ X = A ~> G

------------------ :: put
G1 |- X := A ~> G

------------------ :: return
G1 |- return A ~> G


defn
G |- v : A ::  :: valHasType :: 'vty_' by


defn
G |- e : C ::  :: compHasType :: 'cty_' by

G |- v : A
------------------ :: ret
G |- return v : A

G1 |- e1 : E ; A
G1 |- E ~> G2
G2, x : A |- e2 : C
--------------------------- :: let
G1 |- let x = e1 ; e2 : C

G, x : A |- e : C
----------------------- :: lam
G |- \x => e : A -> C

G, x : {C} |- e : C
--------------------- :: fix
G |- \x := e : C

G1 |- v : A
G1 |- e : E ; A -> C
------------------------- :: app
G1 |- e v : E ; C

G, within X |- e : C
------------------------ :: nest
G |- X { e } : X { C }

G |- v1 : $ Z
G ~> X ; Y
G |- v2 : A
---------------------------------------- :: put
G |- v1 := v2 : X(Y(Z)) := A ; & X(Y(Z)) A

G |- v : & X A
----------------------- :: get
G |- @ v : @ X = A ; A

% let fields = v ; e :: :: letBindRecord
% switch v { cases } :: :: switchVariant
% assert v1 = v2 :: :: assertEq
% { namedBranches } :: :: namedBranches
%  e => v :: :: selectBranch


defn
G |- t : E  :: :: traceHasEff :: 'tr_' by

G |- v : A
--------------------------- :: return
G |- return v : return A

G |- t1 : E1
G |- t2 : E2
----------------------- :: seq
G |- t1 ; t2 : E1 ; E2

G |- v : A
G |- X : #syms
------------------------ :: put
G |- X := v : X := A

G |- v : A
G |- X : #syms
------------------------ :: get
G |- @ X = v : @ X = A

G |- t : E
G |- X : #syms
------------------------ :: nest
G |- X { t } : X { E }
